import { VercelRequest, VercelResponse } from '@vercel/node';
import { kv } from '@vercel/kv';

// PATCH /api/reports/:id - Update report status
async function handlePatch(req: VercelRequest, res: VercelResponse) {
  try {
    console.log(`[PATCH] Starting update for report ${req.query.id}`);
    console.log(`[PATCH] Headers received:`, Object.keys(req.headers));
    console.log(`[PATCH] Body type:`, typeof req.body);
    console.log(`[PATCH] Raw body:`, req.body);
    
    // Check API key if configured
    const apiSecret = process.env.API_KEY;
    if (apiSecret) {
      const providedKey = req.headers['x-api-key'] || req.headers['X-API-Key'];
      const providedKeyStr = Array.isArray(providedKey) ? providedKey[0] : providedKey;
      console.log(`[PATCH] API key check - Expected: ${apiSecret?.substring(0, 10)}..., Provided: ${providedKeyStr?.substring(0, 10)}...`);
      if (providedKeyStr !== apiSecret) {
        console.log(`[PATCH] API key mismatch - returning 401`);
        return res.status(401).json({ error: 'Unauthorized' });
      }
    } else {
      console.log(`[PATCH] No API_KEY env var configured`);
    }
    
    const { id } = req.query;
    
    // Parse body for PATCH request
    let body;
    try {
      body = typeof req.body === 'string' ? JSON.parse(req.body) : req.body;
      console.log(`[PATCH] Parsed body:`, body);
    } catch (e) {
      console.log(`[PATCH] Failed to parse body:`, e);
      return res.status(400).json({ error: 'Invalid JSON body' });
    }
    
    const { status } = body;
    
    // Validate inputs
    if (!id || typeof id !== 'string') {
      return res.status(400).json({ error: 'Invalid report ID' });
    }
    
    if (!status || !['pending', 'reviewed', 'archived'].includes(status)) {
      return res.status(400).json({ error: 'Invalid status' });
    }
    
    // Check if report exists
    const reportKey = `report:${id}`;
    const report = await kv.get(reportKey);
    
    if (!report) {
      return res.status(404).json({ error: 'Report not found' });
    }
    
    // Update status
    const updatedReport = {
      ...(report as any),
      status,
      updatedAt: new Date().toISOString()
    };
    
    console.log(`[PATCH] Updating KV with key ${reportKey}, new status: ${status}`);
    await kv.set(reportKey, updatedReport);
    
    // Verify the update
    const verifyReport = await kv.get(reportKey);
    console.log(`[PATCH] Verification - Report ${id} status is now: ${(verifyReport as any)?.status}`);
    
    res.status(200).json({ 
      id, 
      status, 
      message: 'Report status updated successfully' 
    });
  } catch (error) {
    console.error('PATCH /api/reports/:id error:', error);
    res.status(500).json({ error: 'Failed to update report' });
  }
}

// Main handler
export default async function handler(req: VercelRequest, res: VercelResponse) {
  // CORS headers
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'PATCH, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, X-API-Key');
  
  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }
  
  if (req.method === 'PATCH') {
    return handlePatch(req, res);
  }
  
  return res.status(405).json({ error: 'Method not allowed' });
}
